"""Vulnerability database and CVE matching"""

import asyncio
import aiohttp
from typing import Dict, List, Optional
from ..utils.logging import get_logger

logger = get_logger('vulnerability_db')


class VulnerabilityDatabase:
    """Query vulnerability databases for known CVEs"""
    
    def __init__(self, timeout: int = 30):
        self.timeout = timeout
        
    async def search_cve(self, product: str, version: Optional[str] = None) -> List[Dict]:
        """
        Search for CVEs related to a product
        
        Args:
            product: Product name (e.g., 'Apache', 'nginx')
            version: Optional specific version
            
        Returns:
            List of CVEs
        """
        cves = []
        
        # Mock CVE database (in production, would query NVD API)
        # https://services.nvd.nist.gov/rest/json/cves/2.0
        
        logger.info(f"Searching CVEs for {product}" + (f" {version}" if version else ""))
        
        # For now, return placeholder indicating where to integrate
        return [{
            "id": "CVE-XXXX-XXXX",
            "description": f"Placeholder - Integrate with NVD API for {product}",
            "severity": "info",
            "published": None,
            "references": []
        }]
    
    def match_vulnerabilities(self, technologies: List[Dict]) -> List[Dict]:
        """
        Match detected technologies against vulnerability database
        
        Args:
            technologies: List of detected technologies
            
        Returns:
            List of potential vulnerabilities
        """
        vulnerabilities = []
        
        for tech in technologies:
            tech_name = tech.get('name', '')
            tech_version = tech.get('version', '')
            
            # Check for known vulnerable versions
            vuln = self._check_known_vulnerabilities(tech_name, tech_version)
            if vuln:
                vulnerabilities.extend(vuln)
        
        return vulnerabilities
    
    def _check_known_vulnerabilities(self, product: str, version: str) -> List[Dict]:
        """
        Check for known vulnerabilities (placeholder for real DB)
        
        Args:
            product: Product name
            version: Version string
            
        Returns:
            List of vulnerabilities
        """
        # This would integrate with real vulnerability databases
        # For now, return common vulnerabilities to check for
        
        vulnerabilities = []
        
        # Example vulnerability checks
        if 'Apache' in product:
            if version and '2.4' in version:
                vulnerabilities.append({
                    "type": "Potential vulnerability",
                    "product": product,
                    "version": version,
                    "description": "Apache 2.4.x may have known vulnerabilities - check NVD",
                    "severity": "info",
                    "recommendation": "Verify Apache version and patch level"
                })
        
        if 'WordPress' in product:
            vulnerabilities.append({
                "type": "Configuration",
                "product": product,
                "description": "WordPress detected - check for outdated plugins and themes",
                "severity": "medium",
                "recommendation": "Audit WordPress plugins and keep updated"
            })
        
        if 'PHP' in product:
            vulnerabilities.append({
                "type": "Version check",
                "product": product,
                "version": version,
                "description": "PHP detected - ensure using supported version",
                "severity": "info",
                "recommendation": "Verify PHP version is actively supported"
            })
        
        return vulnerabilities
    
    def assess_risk_score(self, profile: Dict) -> Dict:
        """
        Assess overall risk score based on profile
        
        Args:
            profile: Target profile
            
        Returns:
            Risk assessment
        """
        score = 0
        factors = []
        
        # Check for open high-risk ports
        open_ports = profile.get('network_scan', {}).get('open_ports', [])
        high_risk_ports = [21, 23, 135, 139, 445, 3389]  # FTP, Telnet, RPC, SMB, RDP
        
        for port_info in open_ports:
            if port_info['port'] in high_risk_ports:
                score += 10
                factors.append(f"High-risk port {port_info['port']} ({port_info['service']}) is open")
        
        # Check for missing security headers
        http_fingerprint = profile.get('http_fingerprint', {})
        security_headers = http_fingerprint.get('security_headers', {})
        
        required_headers = [
            'Strict-Transport-Security',
            'Content-Security-Policy',
            'X-Frame-Options',
            'X-Content-Type-Options'
        ]
        
        for header in required_headers:
            if header not in security_headers:
                score += 5
                factors.append(f"Missing security header: {header}")
        
        # Check for detected vulnerabilities
        vulnerabilities = profile.get('vulnerabilities', [])
        for vuln in vulnerabilities:
            severity = vuln.get('severity', 'info')
            if severity == 'critical':
                score += 30
            elif severity == 'high':
                score += 20
            elif severity == 'medium':
                score += 10
            else:
                score += 5
            factors.append(f"{severity.upper()}: {vuln.get('description', 'Unknown')}")
        
        # Check for exposed sensitive paths
        discovered_paths = profile.get('discovered_paths', [])
        sensitive_paths = ['/.git', '/.env', '/admin', '/phpmyadmin']
        
        for path_info in discovered_paths:
            if any(sens in path_info['path'] for sens in sensitive_paths):
                score += 15
                factors.append(f"Exposed sensitive path: {path_info['path']}")
        
        # Determine risk level
        if score >= 80:
            risk_level = 'CRITICAL'
        elif score >= 60:
            risk_level = 'HIGH'
        elif score >= 40:
            risk_level = 'MEDIUM'
        elif score >= 20:
            risk_level = 'LOW'
        else:
            risk_level = 'MINIMAL'
        
        return {
            "score": min(score, 100),  # Cap at 100
            "level": risk_level,
            "factors": factors,
            "recommendations": self._generate_recommendations(factors)
        }
    
    def _generate_recommendations(self, factors: List[str]) -> List[str]:
        """Generate recommendations based on risk factors"""
        recommendations = []
        
        if any('port' in f.lower() for f in factors):
            recommendations.append("Close unnecessary ports and services")
        
        if any('security header' in f.lower() for f in factors):
            recommendations.append("Implement security headers (HSTS, CSP, X-Frame-Options, etc.)")
        
        if any('admin' in f.lower() or 'phpmyadmin' in f.lower() for f in factors):
            recommendations.append("Restrict access to admin interfaces with IP whitelisting")
        
        if any('.git' in f or '.env' in f for f in factors):
            recommendations.append("Remove exposed configuration files and directories")
        
        if any('wordpress' in f.lower() for f in factors):
            recommendations.append("Update WordPress, plugins, and themes to latest versions")
        
        return recommendations
