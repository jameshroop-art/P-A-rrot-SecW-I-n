"""
Gated exploitation with multi-layer authorization

Prevents unauthorized use through multiple security gates
"""

import getpass
import hashlib
import jwt
from datetime import datetime, timedelta
from typing import Dict, Optional, List
from ..utils.logging import get_logger, AuditLogger
from ..utils.networking import is_safe_environment

logger = get_logger('gated_exploiter')
audit = AuditLogger()


class AuthorizationGate:
    """Multi-layer authorization system for exploitation"""
    
    def __init__(self, config: Dict):
        self.config = config
        self.safe_environments = config.get('safe_environments', [])
        self.whitelist = []  # Would load from config/database
        self.require_auth = config.get('exploitation', {}).get('require_auth', True)
        self.require_legal_ack = config.get('exploitation', {}).get('require_legal_ack', True)
        
    def is_safe_environment(self, target: str) -> bool:
        """Check if target is in safe testing environment"""
        return is_safe_environment(target, self.safe_environments)
    
    def is_target_authorized(self, target: str) -> bool:
        """Check if target is in whitelist"""
        # Check safe environments
        if self.is_safe_environment(target):
            logger.info(f"Target {target} is in safe environment - authorized")
            return True
        
        # Check whitelist
        for whitelisted in self.whitelist:
            if target.lower() == whitelisted.lower():
                logger.info(f"Target {target} is whitelisted - authorized")
                return True
        
        logger.warning(f"Target {target} is NOT authorized")
        return False
    
    def add_to_whitelist(self, target: str, auth_token: str, reason: str) -> bool:
        """
        Add target to whitelist with proper authorization
        
        Args:
            target: Target to whitelist
            auth_token: Authorization token
            reason: Reason for authorization
            
        Returns:
            True if successfully added
        """
        # Verify authorization token
        if not self._verify_auth_token(auth_token):
            logger.error("Invalid authorization token")
            return False
        
        # Add to whitelist
        self.whitelist.append(target)
        
        # Audit log
        audit.log_action(
            user=self._get_current_user(),
            target=target,
            action=f"whitelist_add: {reason}",
            result="success",
            auth_token=auth_token
        )
        
        logger.info(f"Added {target} to whitelist: {reason}")
        return True
    
    def request_exploitation_access(self, target: str, reason: str) -> Dict:
        """
        Request access to exploit target with multi-step authorization
        
        Args:
            target: Target to exploit
            reason: Business justification
            
        Returns:
            Authorization result
        """
        logger.info(f"Exploitation access requested for {target}")
        
        result = {
            "target": target,
            "authorized": False,
            "gates_passed": [],
            "gates_failed": [],
            "auth_token": None
        }
        
        # Gate 1: Check if exploitation is enabled
        if not self.config.get('mode', {}).get('exploitation', {}).get('enabled', False):
            result["gates_failed"].append("Exploitation mode not enabled in config")
            logger.error("Gate 1 FAILED: Exploitation disabled in config")
            return result
        
        result["gates_passed"].append("Exploitation mode enabled")
        logger.info("Gate 1 PASSED: Exploitation enabled")
        
        # Gate 2: Check if target is safe environment (auto-approve)
        if self.is_safe_environment(target):
            result["authorized"] = True
            result["gates_passed"].append("Safe environment detected - auto-authorized")
            result["auth_token"] = self._generate_auth_token(target, reason, "safe_env")
            
            audit.log_action(
                user=self._get_current_user(),
                target=target,
                action=f"exploitation_authorized_safe_env: {reason}",
                result="success",
                auth_token=result["auth_token"]
            )
            
            logger.info("Gate 2 PASSED: Safe environment - AUTHORIZED")
            return result
        
        # Gate 3: Check whitelist
        if not self.is_target_authorized(target):
            result["gates_failed"].append("Target not in whitelist")
            logger.error("Gate 3 FAILED: Target not authorized")
            return result
        
        result["gates_passed"].append("Target is whitelisted")
        logger.info("Gate 3 PASSED: Target whitelisted")
        
        # Gate 4: User authentication (if required)
        if self.require_auth:
            print("\n" + "="*60)
            print("GATE 4: USER AUTHENTICATION")
            print("="*60)
            password = getpass.getpass("Enter authorization password: ")
            
            if not self._verify_password(password):
                result["gates_failed"].append("Authentication failed")
                logger.error("Gate 4 FAILED: Authentication failed")
                
                audit.log_action(
                    user=self._get_current_user(),
                    target=target,
                    action=f"exploitation_denied_auth: {reason}",
                    result="failed"
                )
                
                return result
            
            result["gates_passed"].append("User authenticated")
            logger.info("Gate 4 PASSED: Authentication successful")
        
        # Gate 5: Legal acknowledgment (if required)
        if self.require_legal_ack:
            print("\n" + "="*60)
            print("GATE 5: LEGAL ACKNOWLEDGMENT")
            print("="*60)
            print("\nWARNING: Unauthorized access to computer systems is ILLEGAL.")
            print("You MUST have explicit written authorization to test this target.")
            print("\nI acknowledge that:")
            print("1. I have written authorization to test this target")
            print("2. I understand unauthorized access is illegal")
            print("3. I accept full legal responsibility for my actions")
            print("\nType 'I ACCEPT FULL RESPONSIBILITY' to continue:")
            
            confirmation = input("> ").strip()
            
            if confirmation != "I ACCEPT FULL RESPONSIBILITY":
                result["gates_failed"].append("Legal acknowledgment not accepted")
                logger.error("Gate 5 FAILED: Legal acknowledgment declined")
                return result
            
            result["gates_passed"].append("Legal acknowledgment accepted")
            logger.info("Gate 5 PASSED: Legal acknowledgment accepted")
        
        # All gates passed - grant authorization
        result["authorized"] = True
        result["auth_token"] = self._generate_auth_token(target, reason, "full_auth")
        
        audit.log_action(
            user=self._get_current_user(),
            target=target,
            action=f"exploitation_authorized: {reason}",
            result="success",
            auth_token=result["auth_token"]
        )
        
        logger.info(f"ALL GATES PASSED: Exploitation authorized for {target}")
        
        return result
    
    def verify_authorization(self, target: str, auth_token: str) -> bool:
        """Verify authorization token for target"""
        try:
            # Decode JWT
            payload = jwt.decode(
                auth_token,
                self._get_secret_key(),
                algorithms=['HS256']
            )
            
            # Verify target matches
            if payload.get('target') != target:
                logger.error("Authorization token target mismatch")
                return False
            
            # Verify not expired
            exp = payload.get('exp', 0)
            if datetime.utcnow().timestamp() > exp:
                logger.error("Authorization token expired")
                return False
            
            logger.info("Authorization token verified")
            return True
            
        except jwt.InvalidTokenError as e:
            logger.error(f"Invalid authorization token: {e}")
            return False
    
    def _verify_password(self, password: str) -> bool:
        """Verify authorization password"""
        # In production, would check against secure credential store
        # For now, simple check (NOT FOR PRODUCTION)
        expected_hash = "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8"  # "password"
        password_hash = hashlib.sha256(password.encode()).hexdigest()
        return password_hash == expected_hash
    
    def _verify_auth_token(self, token: str) -> bool:
        """Verify authorization token"""
        try:
            jwt.decode(token, self._get_secret_key(), algorithms=['HS256'])
            return True
        except:
            return False
    
    def _generate_auth_token(self, target: str, reason: str, auth_type: str) -> str:
        """Generate JWT authorization token"""
        payload = {
            'target': target,
            'reason': reason,
            'auth_type': auth_type,
            'user': self._get_current_user(),
            'iat': datetime.utcnow(),
            'exp': datetime.utcnow() + timedelta(hours=24)
        }
        
        token = jwt.encode(payload, self._get_secret_key(), algorithm='HS256')
        return token
    
    def _get_secret_key(self) -> str:
        """Get JWT secret key"""
        # In production, load from secure config
        return "forensicsense-secret-key-change-in-production"
    
    def _get_current_user(self) -> str:
        """Get current user"""
        import os
        return os.getenv('USER', 'unknown')


class GatedExploiter:
    """
    Main exploitation engine with authorization gates
    """
    
    def __init__(self, config: Dict):
        self.config = config
        self.auth_gate = AuthorizationGate(config)
        self.audit = AuditLogger()
        
    def can_exploit(self, target: str) -> bool:
        """Check if target can be exploited (quick check)"""
        return self.auth_gate.is_target_authorized(target)
    
    def request_access(self, target: str, reason: str) -> Dict:
        """Request exploitation access"""
        return self.auth_gate.request_exploitation_access(target, reason)
    
    def exploit(self, target: str, auth_token: str, exploit_config: Dict) -> Dict:
        """
        Execute exploitation with authorization check
        
        Args:
            target: Target to exploit
            auth_token: Authorization token
            exploit_config: Exploitation configuration
            
        Returns:
            Exploitation results
        """
        # Verify authorization
        if not self.auth_gate.verify_authorization(target, auth_token):
            logger.error("Authorization verification failed")
            return {
                "success": False,
                "error": "Authorization verification failed"
            }
        
        logger.info(f"Exploitation authorized - proceeding with {target}")
        
        # Audit log
        self.audit.log_action(
            user=self.auth_gate._get_current_user(),
            target=target,
            action=f"exploitation_started: {exploit_config.get('type', 'unknown')}",
            result="started",
            auth_token=auth_token
        )
        
        # Execute exploitation
        # (Implementation would go here)
        
        result = {
            "success": True,
            "message": "Exploitation framework ready (implementation in progress)"
        }
        
        # Audit log completion
        self.audit.log_action(
            user=self.auth_gate._get_current_user(),
            target=target,
            action="exploitation_completed",
            result="success" if result["success"] else "failed",
            auth_token=auth_token
        )
        
        return result
