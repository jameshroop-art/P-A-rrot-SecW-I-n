"""
AI-powered exploit planning

Plans multi-step attack chains based on target profile
"""

from typing import Dict, List, Optional
from ..utils.logging import get_logger

logger = get_logger('exploit_planner')


class ExploitPlanner:
    """
    Plan exploitation strategy based on target intelligence
    """
    
    def __init__(self):
        self.attack_patterns = self._load_attack_patterns()
    
    def plan_attack(self, target_profile: Dict) -> List[Dict]:
        """
        Plan attack chain based on target profile
        
        Args:
            target_profile: Target intelligence profile
            
        Returns:
            List of attack steps
        """
        logger.info("Planning attack chain")
        
        attack_chain = []
        
        # Analyze open ports
        open_ports = target_profile.get('network_scan', {}).get('open_ports', [])
        
        for port in open_ports:
            port_num = port.get('port')
            service = port.get('service', 'unknown')
            
            # Suggest attacks based on service
            if service == 'ssh' or port_num == 22:
                attack_chain.append({
                    'step': len(attack_chain) + 1,
                    'target': f'SSH on port {port_num}',
                    'attack_type': 'credential_attack',
                    'methods': ['credential_stuffing', 'brute_force'],
                    'priority': 'medium'
                })
            
            elif service in ['http', 'https'] or port_num in [80, 443, 8080, 8443]:
                # Check for vulnerabilities
                technologies = target_profile.get('http_fingerprint', {}).get('technologies', [])
                
                for tech in technologies:
                    if 'WordPress' in tech.get('name', ''):
                        attack_chain.append({
                            'step': len(attack_chain) + 1,
                            'target': 'WordPress installation',
                            'attack_type': 'cms_exploit',
                            'methods': ['plugin_exploit', 'theme_exploit', 'xmlrpc_attack'],
                            'priority': 'high'
                        })
                    
                    if 'PHP' in tech.get('name', ''):
                        attack_chain.append({
                            'step': len(attack_chain) + 1,
                            'target': 'PHP application',
                            'attack_type': 'web_exploit',
                            'methods': ['lfi', 'rfi', 'php_injection'],
                            'priority': 'high'
                        })
                
                # Check for discovered paths
                discovered = target_profile.get('discovered_paths', [])
                for path_info in discovered:
                    path = path_info.get('path', '')
                    
                    if '/admin' in path or '/login' in path:
                        attack_chain.append({
                            'step': len(attack_chain) + 1,
                            'target': f'Admin panel: {path}',
                            'attack_type': 'authentication',
                            'methods': ['default_credentials', 'sqli_bypass', 'brute_force'],
                            'priority': 'high'
                        })
        
        # Prioritize attack chain
        attack_chain.sort(key=lambda x: {'critical': 0, 'high': 1, 'medium': 2, 'low': 3}.get(x['priority'], 4))
        
        # Re-number steps
        for i, step in enumerate(attack_chain, 1):
            step['step'] = i
        
        logger.info(f"Planned {len(attack_chain)} attack steps")
        
        return attack_chain
    
    def _load_attack_patterns(self) -> Dict:
        """Load known attack patterns"""
        # In production, would load from database or ML model
        return {
            'ssh': ['credential_stuffing', 'key_leak', 'version_exploit'],
            'http': ['sqli', 'xss', 'csrf', 'lfi', 'rfi', 'ssrf'],
            'smb': ['eternal_blue', 'smb_relay', 'null_session'],
            'rdp': ['bluekeep', 'credential_attack'],
        }
    
    def suggest_tools(self, attack_step: Dict) -> List[str]:
        """
        Suggest tools for attack step
        
        Args:
            attack_step: Attack step from plan
            
        Returns:
            List of suggested tools
        """
        attack_type = attack_step.get('attack_type', '')
        
        tool_map = {
            'credential_attack': ['hydra', 'medusa', 'ncrack'],
            'web_exploit': ['sqlmap', 'nikto', 'burpsuite'],
            'cms_exploit': ['wpscan', 'joomscan', 'droopescan'],
            'network_exploit': ['metasploit', 'exploit-db'],
        }
        
        return tool_map.get(attack_type, ['manual_testing'])
